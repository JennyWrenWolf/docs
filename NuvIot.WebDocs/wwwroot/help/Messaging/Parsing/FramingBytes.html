<p><a href="#/Index.md">Home</a> &gt; <a href="#/Messaging/Index.md">Device Messaging</a> &gt; <a href="#/Messaging/Parsing/Index.md">Parsing</a> &gt; <a href="#/Messaging/Parsing/ParsingBinaryMessages.md">Parsing Binary Messages</a></p>
<h1>Framing Bytes</h1>
<p>When parsing a binary message you can use framing bytes to ensure your message is in the exact format you expect as well set check points for relative locations in your message (not implemented as of 5/18/2017)</p>
<p>Framing bytes consist of two parameters:</p>
<p>*Byte - Two character representation of the byte for example 0D would be 13 or CR
*Index - Index with in the message where this character should be located.</p>
<p><em>NOTE</em> In this case the index or binary offset is 0 based which is different than parsing delimited values where the index of the delimited value is 1.</p>
<h3>Example</h3>
<p>For example the binary message:</p>
<p><code>01 32 02 43 52 08 03 04</code></p>
<p>You could specify the following Framing Bytes:</p>
<p>| Position | Byte | Description |
|  0  | 01 | Look for SOH in the first position |
|  2  | 02 | Look for STX in the second position |
|  6  | 03 | Look for ETX in the sixth position |
|  7  | 04 | Look for EOT in the sevent position |</p>
<p>With the above message, the parsing would succeed.</p>
<p>If you use the same framing bytes with the message</p>
<p><code>01 32 43 02 43 52 08 03 04</code></p>
<p>The parsing of the message would fail since the character <code>02 (STX)</code> is located at position 3 not position 2.</p>
<hr /><h4>Documentation Built: 9/6/2017 09:09:00</h4><h4>Copyright Sofware Logistics - 2017</h4>